== Capítulo 3. Introducción a Terraform

Como ya se platicó en el capítulo uno, durante el desarrollo de esta obra estaremos utilizando la versión abierta y gratuita de *_Hashicorp Terraform_*, la cual ha tomado mucha popularidad entre intenieros que hacen *_DEVOPS_* y *_CI/CD_*, temas que trataremos más adelante. Y no es casualidad, _Terraform_ ofrece un entorno bien documentado y con cientos de integraciones que permiten a las organizaciones tratar su infraestructura como código al escribir archivos con la declaración del estado deseado de las configuraciones. _Terraform_ usa su propio lenguage llamado *_Hashicorp Configuration Language (HLC)_* qué permite una descripción consisa de los recursos usando bloques de código, argumentos y expresiones.

De la misma manera, _Terraform_ permite correr las verificaciones necesarias antes de aplicar las configuraciones deseadas para asegurarse que los cambios a realizar son factibles y el operador tiene oportunidad de entender qué cambios sucederán y como afectará el ambiente desplegado. Una vez hecho esto el operador puede proceder a aplicar los cambios, para poder llegar al estado deseado solo modificando el delta entre el estado actual y el deseado.

.Código Ejemplo escrito en HCL para AWS
[source,yaml]
----
variable "ami_id" {
  type        = string
  description = "AMI ID to use"
  default     = "ami-09d95fab7fff3776c"
}

variable "instance_type" {
  type        = string
  description = "Instance type to use"
  default     = "t3.micro"
}

variable "availability_zone" {
  type        = string
  description = "Availability Zone to use"
  default     = "us-east-1a"
}
----

=== Características

Algunas de las características más importantes de _Terraform_ son:

[WARNING]
====
Algunos
====

* *Archivos de Configuración Declarativa:* Definición de Infraestructura como código para manejar el ciclo de vida completo, creación de nuevos recursos, manejo de los existentes así como la decomisación cuando estos ya no son necesarios.
* *Modulos instalables:* Intalación automática de modulos de la comunidad o terceros desde el registro de _Hashicorp_ por medio de `terraform init`.
* *Planeación y predicción de cambios:* _Terraform_ permite a los operadores hacer cambios a la infraestructura de manera segura y predectible.
* *Graficación de dependencias
* *Manejo del estado:* Mapeo de la configuración de los recursos del mundo real, mantenimiento de los _metadatos_ y mejoramiento del _performance_ en infraestructuras grandes
* *Registro de más de 500 proveedores:* El operador puede escoger de una serie de proveedores para las diferentes plataformas de nube disponibles en el mercado.

=== Casos de uso

Algunos de los casos de uso que se pueden cubrir con terraform son: footnote:[https://www.terraform.io/intro/use-cases.html]

* Despliegue de aplicaciones en _Heruku_.
* Aplicaciones Multi Capa. footnote:[Este es el caso de uso específico que estaremos cubriendo en esta obra]
* _Clusteres_ de Autoservicio.
* Demostraciones de _Software_.
* Ambientes deshechables.
* Despliegues multi nube.

=== Instalación de _Terraform_

En esta sección estaremos discutiendo la instalación del binario de _Terraform_ en nuestro equipo personal, donde crearemos un ambiente de desarrollo para escribir, probar y desplegar nuestra infraestructura. Existen varios métodos para la instalación de _Terraform_ a continuación discutiremos los más importantes.

==== Instalación Manual

Para la instalación manual de _Terraform_, necesitamos encontrar el paquete apropiado footnote:[https://www.terraform.io/downloads.html] para nuestro sistema operativo y bajarlo, este será un archivo _zip_.

Una vez que se haya bajado _Terraform_, procederemos a expander el archivo _zip_. Encontraremos que es un solo binario llamado `terraform`. Todos los demás archivos que pudiera contener el archivo _zip_ pueden ser borrados de manera segura sin que esto afecte el funcionamiento de _Terraform_.

Finalmente, nos aseguraremos de que `terraform` se encuentre disponible en nuestro `PATH`. Esto se realiza de manera diferente, dependiendo el sistema operativo.

===== Mac o Linux

Obtenemos la lista de rutas que están disponibles en la variable de entorno `PATH`

[source,batch]
----
echo $PATH
----

Movemos el binario te _Terraform_ a uno de las rutas listadas. Este comando asume que el binario se encuentra en el archivo de descargas y que `PATH` contiene `/usr/local/bin`, personaliza en caso de las rutas en tu sistema operativo sean diferentes.

[source,batch]
----
mv ~/Downloads/terraform /usr/local/bin/
----

==== Windows

En la siguiente dirección de internet, podemos encontrar las instrucciones exactas para modificar el `PATH` en _Windows_ através de la interfaz gráfica: `https://stackoverflow.com/questions/1618280/where-can-i-set-path-to-make-exe-on-windows`

==== Instalación con _Homebrew_ en _MacOS_

_Homebrew_ es un manejador de paquetes de fuente abierta para el sistema operativo _MacOS_. Instala la _formula_ oficial de _Terraform_ desde la terminal.

Primero, installamos el _tap_ de _HashiCorp_, un repositorio para todos los paquetes de _Homebrew_ de la compañia:

[source,batch]
----
brew tap hashicorp/tap
----

Ahora, Instalamos _Terraform_ con `hashicorp/tap/terraform`

[source,batch]
----
brew install hashicorp/tap/terraform
----

Para actualizar a la última versión, ejecutamos:

[source,batch]
----
brew upgrade hashicorp/tap/terraform
----

==== Instalación con _Chocolatey_ en _Windows_

_Chocolatey_ es un manejador de paquetes de codigo abierto para _Windows_. Installamos el paquete de _Terraform_ desde la linea de comandos.

[source,batch]
----
choco install terraform
----


==== Instalación en Linux

===== Ubuntu/Debian

Agregamos la llave _GPG_ de _HashiCorp_.

[source,batch]
----
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
----

Agregamos los repositorios oficiales de _HashiCorp_ para _Linux_.

[source,batch]
----
sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
----

Actualización e instalación.

[source,batch]
----
sudo apt-get update && sudo apt-get install terraform
----

===== CentOS/RHEL

Instalamos `yum-config-manager` para manejar repositorios.

[source,batch]
----
sudo yum install -y yum-utils
----

Usamos `yum-config-manager` para agregar el repositorio oficial de _HachiCorp_ para _Linux_

[source,batch]
----
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo
----

Instalamos

[source,batch]
----
sudo yum -y install terraform
----

===== Fedora

Instalamos `dnf config-manager` para manejar repositorios.

[source,batch]
----
sudo dnf install -y dnf-plugins-core
----

Usamos `dnf config-manager` para agregar el repositorio oficial de _HachiCorp_ para _Linux_

[source,batch]
----
sudo dnf config-manager --add-repo https://rpm.releases.hashicorp.com/fedora/hashicorp.repo
----

Instalamos

[source,batch]
----
sudo dnf -y install terraform
----

==== Verificación de la instalación.

Para verificar la instalación abrimos una nueva terminal y ejecutamos `terraform -help`

[source,batch]
----
terraform -help
Usage: terraform [global options] <subcommand> [args]

The available commands for execution are listed below.
The primary workflow commands are given first, followed by
less common or more advanced commands.
...
----

Cualquier sub comando despues de `terraform -help` permite aprender más sobre el mismo.

[source,batch]
----
terraform -help plan
----

Con esto finalizamos la instalación de _Terraform_ y estamos listos para empezar a construir infraestructura como código.

=== Contrucción de Infraestructura

Con _Terraform_ installado, estamos listos para crear nuestra primera infraestructura.

Vamos a aprovisionar una *_Amazon Machine Image (AMI)_* en *_AWS_* esto lo haremos de esta manera, dado de las _AMIs_ son muy populares.

==== Pre requisitos

Para continuar, necesitamos:

* Una cuenta de _AWS_
* La intefaz de Linea de comando de _AWS_
* Las credenciales de _AWS_ configuradas localmente

Esto está descrito en el Apéndice xref:apendice001.adoc[Creación y configuración de una cuenta de Amazon Web Services]

==== Escribir configuraciones

El set de archivos que es usado para describir la infraestructura en _Terraform_ es conocido como _Terraform Configuration_. Vamos a escribir nuestra primera configuración ahora para lanzar una instancia de _EC2 de AWS_.

Cada configuración debe estar en su propio directorio. Crearemos un directorio para esta nueva configuración.

[source,bash]
----
mkdir iac-libro-aws-instancia
----

Nos cambiamos al directorio recién creado
[source,bash]
----
cd iac-libro-aws-instancia
----

Pegamos la configuración que está a continuación dentro de un archivo que tenga por nombre `ejemplo.tf` y lo guardamos. _Terraform_ carga todos los archivos en el directorio actual que tengan la extención `.tf`


[source,bash]
----
include::{sourcedir}/cap003/ejemplo.tf[]
----

Esta es una configuración completa de _Terraform_ y está lista para ser aplicada. En las siguientes secciones, veremos como funciona cada uno de estos bloques en más detalle.

===== Bloques de _Terraform_

El bloque `terraform {}` es requerido para que _Terraform_ conosca qué proveedor tiene que descargar desde el registro de _Terraform_. En la condiguración anterior, el proveedor `aws` está definido como `hashicorp/aws` que es una abreviación de `redistry.terraform.io/hashicorp/aws`.

También podemos asignar una versión definida en el bloque `required_providers`. El argumento `version` es opcional, pero recomendado.

===== Proveedores

El bloque `provider` configura el nombre del proveedor, en nuestro caso `aws`, que es responsable de crear y manejar los recursos. Un proveedor es un _plugin_ que _Terraform_ usa para traducir las interacciones con las _API_ del servicio a administrar. Un proveedor es el responsable por entender tales interacciones y exponer los recursos. Por el hecho de que _Terraform_ puede interactuar con cualquier _API_, podemos representar casi cualquier tipo de infraestructura como recursos en _Terraform_.

El atributo `profile` en nuestro bloque de proveedor se refiere, en este caso, a las credenciales de _AWS_ almacenadas en la el archivo de configuración de _AWS_, que se creo cuando se hizo la configuración del _CLI_ de _AWS_. La mejor práctica recomendada, es que no se use credenciales directamente en los archivos `.tf`.

Pueden existir multiples bloques de proveedor en caso de ser necesario. Podemos, incluso, usar multiples proveedores juntos. Por ejemplo podemos pasar el identificador de una intancia de _AWS_ para monitorear tal recurso con _DataDog_.

===== Recursos

El bloque de `resources` define una pieza de la infraestructura. Un recurso puede er un componente físico o virtual como una instancia de _EC2_ o puede ser un recurso lógico como una _IP elástica_.

El bloque de recursos tiene dos entradas antes del bloque como tal: el tipo de recurso y el nombre del recurso. en este ejemplo, el tipo de recurso es `aws_instance` y el nombre es `ejemplo`. El prefijo en el tipo de recurso se mapea al proveedor. En nuestro caso `aws_instance` automaticamente le dice a _Terraform_ que este serña manejado por el proveedor _aws_.

Los argumentos del recurso están dentro del bloque del recurso. Los artumentos pueden ser cosas como el tamaño de la máquina, el nombre de la imagen del disco, o identificadores del _VPC_ donde se desplegará la instancia. Para entender los argumentos opcionales y requeridos de cada tipo de recurso, es necesario consultar los documentos de referencia de _HashiCorp_ footnote:[https://www.terraform.io/docs/providers/index.html]. En el caso de la instancia de _EC2_ que crearemos espeficicamos un _AMI_ para _Ubuntu_ y el tamaño requerido será `t2.micro` que califica como _free tier_ en nuestra cuenta de _AWS_.

==== Inicializando el directorio

Cuando creamos una nueva configuración (o hacemos _checkout_ de una configuración existente desde el control de versiones) necesitamos inicializar el directorio con `terrarom init`.

_Terraform_ usa una arquitectura basada en _plugins_ que soporta cientos de proveedores de servicios de infraestructura. Inicializar un directorio de configuracion, descarga e instala los proveedores usados en la configuración qué, en este caso, es el proveedor `aws`. Los comandos subsecuentes, usarán los datos y configuraciones locales hechos durante la inicialización.

Iniciemos el directorio.

[source,bash]
----
$ terraform init

Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/aws versions matching "~> 2.70"...
- Installing hashicorp/aws v2.70.0...
- Installed hashicorp/aws v2.70.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
----

_Terraform_ descarga el proveedor `aws` y lo instala en un subdirectorio oculto en el directorio actual. La salida muestra la versión del plugin que fue instalada.

==== Formato y validación de la configuración

Una mejor práctica es usar un formato consistente en los archivos y módilos escritos por diferentes equipos. El comando `terraform fmt` automáticamente actualiza la configuración en el directorio actual para una mejor lectura y consistencia.

Formatearemos nuestra condiguración. _Terraform_ retornará los nombres de los archivos formateados. En este caso, nuestro archivo de configuración esta de por sí formateado de manera correcta, es por eso que _Terraform_ no retornará ningún nombre de archivo.

[source,bash]
----
$ terraform fmt
----

Para validar que la configuración es sintáctimanete válida usamos el comando `terraform validate`. Validaremos nuestra configuración, si nuestra configuración es válira _Terraform_ retornará un mensaje éxitoso.

[source,bash]
----
$ terraform validate
Success! The configuration is valid.
----

==== Creación de Infraestructura

En el mismo directorio donde se encuentra `ejemplo.tf` corremos `terraform apply`. Debes ver una salida similar a la mostrada a continuación.

[source,bash]
----
terraform apply

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # aws_instance.example will be created
  + resource "aws_instance" "example" {
      + ami                          = "ami-830c94e3"
      + arn                          = (known after apply)
      + associate_public_ip_address  = (known after apply)
      + availability_zone            = (known after apply)
      + cpu_core_count               = (known after apply)
      + cpu_threads_per_core         = (known after apply)
      + get_password_data            = false
      + host_id                      = (known after apply)
      + id                           = (known after apply)
      + instance_state               = (known after apply)
      + instance_type                = "t2.micro"
      + ipv6_address_count           = (known after apply)
      + ipv6_addresses               = (known after apply)

## ... Salida Omitida ...

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
----

[TIP]
====
Si tu configuración falla al aplicarse, quizá debas personalizar la región usada o remover el VPC por default.
====

This output shows the execution plan, describing which actions Terraform will take in order to change real infrastructure to match the configuration.

The output format is similar to the diff format generated by tools such as Git. The output has a + next to aws_instance.example, meaning that Terraform will create this resource. Beneath that, it shows the attributes that will be set. When the value displayed is (known after apply), it means that the value won't be known until the resource is created.

Terraform will now pause and wait for your approval before proceeding. If anything in the plan seems incorrect or dangerous, it is safe to abort here with no changes made to your infrastructure.

In this case the plan is acceptable, so type yes at the confirmation prompt to proceed. Executing the plan will take a few minutes since Terraform waits for the EC2 instance to become available.


[source,bash]
----
  Enter a value: yes

aws_instance.example: Creating...
aws_instance.example: Still creating... [10s elapsed]
aws_instance.example: Still creating... [20s elapsed]
aws_instance.example: Creation complete after 34s [id=i-0f57d1b36088f27ae]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
----





